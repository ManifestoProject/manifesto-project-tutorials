# Methodology {#methodology}


We describe our methods in this chapter.
Test




## Sampling

The current version of the Manifesto Project Dataset contains information on more than 4000 electoral programmes from around 1000 parties that competed in more than 650 elections in over 50 countries. In the following, we will illustrate the current coverage and sampling strategy in regard to the selection of countries, elections, parties and documents.

### Democratic Countries
The dataset covers electoral programmes from more than 50 different countries. 
The Manifesto Project started at the end of 1979 as the Manifesto Research Group (MRG) supported by the European Consortium of Political Research (ECPR).
Initially, collection and coding was mostly limited to established western democracies (Western Europe, USA, Canada, New Zealand, Australia, Israel and Japan) and went back to all elections after the end of WWII in 1945. 
With the take over of the Comparative Manifestos Project and the breakdown of the Soviet Union, collection and coding were extended to Central and Eastern European countries from the first democratic election in 1990 onwards. 
Most recently, the project extended its data collection to countries in South America. 

_Exceptions_: In the past some countries and elections have been sampled that were not fully-democratic or free and fair, e.g. the coding of elections in Azerbaijan or Belarus.  

``` {r, echo = FALSE, fig.cap = 'Coverage of the Manifesto Project Dataset'}
mpds %>% attach_year() %>% group_by(countryname) %>% distinct(countryname,year) %>%
  ggplot(aes(x = year, y = countryname)) + geom_point()
```
### Parliamentary Elections
Collection is mostly limited to parliamentary (lower house) elections. 
Some of this take place at the same date as eg. presidential elections. This is why platforms might reflect the positions of a party and a candidate. 
Our "sister-project" the [Euromanifesto Project](/information/documents/linkings) collects and codes electoral programmes issued for European parliamentary elections. 

_Exceptions_: In South American countries we mostly collect and code programmes issued at presidential elections. 

### Parties Represented in Parliament
In general, we only collect and code programmes of parties that gained at least one seat in parliament at the focal election. 
Due to the fragmentation of party systems in Central and Eastern European countries, the threshold is increased to two seats there. 

_Exceptions_: There are some exceptions from this rule. 
On the one hand, programmes of some parties were not coded in the past despite having won a seat in parliament because they were considered to be of low relevance.
On the other hand, some parties have been coded although they may not have gained a seat due to their important role for the party system in the past or for other reasons. 

### Electoral Programmes
We seek to collect and code electoral programmes for all parties. 

_Exceptions_: However, some parties do not publish electoral programmes. 
In this case, we look for documents that come closest to electoral programmes by searching for documents that were of great importance during the electoral campaign, that reflect the party's broader programmatic profile and that are written by the parties themselves. 
These substitute documents can for example be a prominent speech by a party leader or a detailed leaflet laying out a party's policy plan. New parties sometimes do not publish a program specifically for one election, but run for an election on their general program.
You can find a [list](/datasets) of coded documents on the download site of the main dataset. Moreover, the [primary documents dataset](/datasets/mppdds) provides additional information on the comparability of the coded documents.

## Coding

Despite the long history of the project, the general coding methodology has only slightly changed over time. The [current version of the coding instructions](https://manifesto-project.wzb.eu/information/documents/handbooks) can be found on the website. The website also provides a [document with changes of the coding instructions over time](https://manifesto-project.wzb.eu/down/papers/Evolution_of_the_Manifesto_Coding_Instructions_and_the_Category_Scheme.pdf).

The following discusses the digitalization of the documents, the coding unit, the coding scheme and the coder training. 

### Digitalization 

### Coding unit

The coding usually encompasses the whole textual part of a party's electoral programs. However, some parts are usually excluded: preambles, text in tables and pictures. 

The first step of the coding process is the unitization of the document. All text is split into so-called quasi-sentences - the general coding unit of the Manifesto Project. 
A quasi-sentence is a single statement. A grammatical sentence can contain more than one quasi sentence, but a quasi-sentence can never span over more than one grammatical sentence. The following example illustrates this process in more detail. The extract below is takem from the 2012 manifesto of the Democratic Party in the US. 

> [...] `r paste(dems_extract$text, sep=" ", collapse="")` [...]
>
> --- Democratic Party (US), Extract from  2012 Electoral Platform

The extract shows the text before the unitization process. The next extract illustrates the extract after the unitization. The coder added two slashes (//) between all quasi-sentences to indicate the end of one and the start of the following quasi-sentence. 

> [...] `r paste(dems_extract$text, sep="//", collapse=" __//__ ")` [...]
>
> --- Democratic Party (US), Extract from 2012 Electoral Platform

In the coding process, each quasi-sentence is allocated one category from a coding scheme encompassing a large variety of policy and issue categories. 
In a next step the text is transformed into a table where each row contains one quasi-sentence. Each quasi-sentence is then allocated one of the categories of the coding scheme. 



```{r, echo=FALSE}
dems_extract %>% 
  select(text,cmp_code) %>% 
  left_join(cmp_labels, by = c("cmp_code" = "pername")) %>% 
  select(-variable) %>% 
  rename(category = cmp_code,description = value, quasi_sentence = text) %>% 
  knitr::kable()
```




Example where bullet list is coded as different quasi sentences. 







### Coding Scheme

```{r, echo=FALSE, message=FALSE, warning=FALSE}
cmp_labels %>% rename(code = pername, description = value) %>% 
  select(-variable) %>% select(code,description) %>%
  DT::datatable(caption="Variable Labels", rownames=FALSE)
```



every quasi-sentence

policy goals



#### Different versions of the coding instructions {#versions}

#### CEE subcategories

cmp introduced cee categories

#### coding instructions 5 

marpor 

### Coding and  Coder Training {#training}


reliability test

reference to variable




## Scaling


```{r}
dems_2012 <- mp_maindataset() %>% 
  filter(date == 201211 & party == 61320) %>% 
  select(matches("per\\d{3}$")) %>% 
  gather(key="per") %>%
  rename(categ=per,share=value) %>%
  arrange(categ) %>%
  mutate(
    category = as.character(str_sub(categ,start=-3,end=-1)),
    categ_num = as.numeric(categ)
  ) 

ggplot(dems_2012,aes(x=reorder(category,categ_num),y=share)) + 
  geom_bar(stat="identity") + coord_flip()
  
```




